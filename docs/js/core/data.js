core.data = [
    {
        "name": "cantools", 
        "children": [
            {
                "content": "# cantools 0.8.8\nThis portable modern web framework is the application-neutral backbone of Civil Action Network. It includes: a pubsub WebSocket server and bot platform; swappable web backends capable of targeting high-concurrency standalone or cloud platforms; a variable-mode application compiler; a broad-spectrum ORM and database migration tools; a built in administrative interface; and a rich modular JavaScript library.\n\nLicense: MIT (see LICENSE)\n\n## Repository Installation (full)\n  - upside: includes full codebase (not just Python)\n  - site: https://github.com/bubbleboy14/cantools\n  - steps\n    - git clone https://github.com/bubbleboy14/cantools.git\n    - cd cantools\n    - python setup.py develop\n\n## Package Installation (limited -- not recommended)\n  - downside\n    - does _not_ include full package (such as client-side web files)\n    - enough to mess around with cantools -- not enough to develop end-to-end applications\n  - package: https://pypi.python.org/pypi/ct\n  - command: easy_install ct\n\n## Hello World\nThis takes less than a moment. Pop open a terminal in your home directory:\n\n\t~$ git clone https://github.com/bubbleboy14/cantools.git\n\t~$ cd cantools/\n\t~/cantools$ python setup.py develop\n\t~/cantools$ cd ..\n\t~$ ctinit hello_world\n\t~$ cd hello_world/\n\t~/hello_world$ ctstart\n\nAnd that's it. Open http://localhost:8080/ in your browser and call it a day.", 
                "name": "about"
            }
        ]
    }, 
    {
        "children": [
            {
                "content": "## ctinit\n### Usage: ctinit [projname] [-r] [--plugins=P1|P2|P3] [--cantools_path=PATH] [--web_backend=BACKEND]\n\n### Options:\n    -h, --help            show this help message and exit\n    -p PLUGINS, --plugins=PLUGINS\n                          which plugins would you like to use in your project?\n    -c CANTOOLS_PATH, --cantools_path=CANTOOLS_PATH\n                          where is cantools? (default: /guessed/path/from/__file__)\n    -w WEB_BACKEND, --web_backend=WEB_BACKEND\n                          web backend. options: dez, gae. (default: dez)\n    -r, --refresh_symlinks\n                          add symlinks to project and configure version control\n                          path exclusion (if desired)\n    -u, --update          update cantools and all managed plugins\n\nNB: it may be necessary to specify --cantools_path. Normally, this is derived from\nthe __file__ property (the location of the ctinit script, init.py). However, if the\npackage lives in your Python dist-packages (as with 'easy_install', as well as\n'setup.py install'), it does not contain the client-side files necessary for an\nend-to-end web application, and these files therefore cannot be symlinked into your\nnew project. In these cases, indicate --cantools_path (the path to the cloned cantools\nrepository on your computer), and everything should work fine.\n\nGenerally speaking, one should clone the cantools github repository, 'setup.py install'\nit (for the 'ct' commands), and then run 'setup.py develop', which will point 'cantools'\nat your cloned cantools repo and keep the package up to date as you periodically 'git pull'\nthe latest version. Similarly, plugins should be kept in 'develop' mode, as they also will\ngenerally have non-python files of consequence.\n\nIn most cases, the developer won't have to pay much attention to this stuff, because\ninitializing or refreshing a project will automatically install any necessary plugins\nthat aren't already present. Similarly, the --update flag pulls down the latest versions\nof cantools and all managed plugins. Thus, plugins are dealt with under the hood without\nany need for the developer to know or do anything beyond 'ctinit -r'.", 
                "name": "init"
            }, 
            {
                "content": "## ctstart\n\n### Usage: ctstart [--web_backend=BACKEND] [--port=PORT] [--datastore=DS_PATH]\r\n\r\n### Options:\r\n    -h, --help            show this help message and exit\r\n    -w WEB_BACKEND, --web_backend=WEB_BACKEND\r\n                          web backend. options: dez, gae. (default: dez)\r\n    -p PORT, --port=PORT  select your port (default=8080)\r\n    -a ADMIN_PORT, --admin_port=ADMIN_PORT\r\n                          select your port (default=8002)\r\n    -d DATASTORE, --datastore=DATASTORE\r\n                          select your datastore file (default=sqlite:///data.db)\r", 
                "name": "start"
            }, 
            {
                "content": "## ctdeploy\n### Usage: ctdeploy [-d|s|p] [-un] [--js_path=PATH]\n\n### Options:\n\n    -h, --help            show this help message and exit\n    -d, --dynamic         switch to dynamic (development) mode\n    -s, --static          switch to static (debug) mode\n    -p, --production      switch to production (garbled) mode\n    -u, --upload          uploads project in specified mode and then switches\n                          back to dynamic (development) mode\n    -n, --no_build        skip compilation step\n    -j JS_PATH, --js_path=JS_PATH\n                          set javascript path (default=js)\n\n### Supports 3 modes:\n    - dynamic (files live in html)\n      - normal development files\n        - dynamic imports throughout\n      - original files are loaded ad-hoc\n        - chrome debugger plays nice\n      - no wire encryption\n      - all imports lazy\n    - static (files live in html-static)\n      - compiler builds same html files\n        - script imports in head\n        - otherwise unmodified source files\n      - original files are directly referenced\n        - chrome debugger prefers\n      - no wire encryption\n      - all hard requirements loaded in head\n        - lazy-designated imports still lazy\n    - production (files live in html-production)\n      - all code is compiled in head\n        - html is compressed\n        - javascript is minified and mangled\n      - original code is unrecognizable\n        - chrome debugger almost useless\n      - wire encryption\n      - designated lazy imports (indicated by second bool arg to CT.require)\n\nGenerates fresh 'static' and 'production' files (from 'development' source files in 'html' on every run, unless -n [or --no_build] flag is used). Mode is established in the app.yaml file, which routes requests to the appropriate directory, and the ct.cfg file, which determines backend behavior, especially regarding encryption.", 
                "name": "deploy"
            }, 
            {
                "content": "## ctpubsub\n### Usage: ctpubsub [-d domain] [-p port]\n\n### Options:\n    -h, --help            show this help message and exit\n    -d DOMAIN, --domain=DOMAIN\n                        use a specific domain (default: localhost)\n    -p PORT, --port=PORT  use a specific port (default: 8888)", 
                "name": "pubsub"
            }, 
            {
                "content": "## ctmigrate\n### Usage: ctmigrate [load|dump] [--domain=DOMAIN] [--port=PORT] [--filename=FILENAME] [--skip=SKIP] [-n]\n\n### Options:\n\t-h, --help            show this help message and exit\n\t-d DOMAIN, --domain=DOMAIN\n\t                      domain of target server (default: localhost)\n\t-p PORT, --port=PORT  port of target server (default: 8080)\n\t-f FILENAME, --filename=FILENAME\n\t                      name of sqlite data file for dumping/loading to/from\n\t                      (default: dump.db)\n\t-s SKIP, --skip=SKIP  don't dump these tables - use '|' as separator, such\n\t                      as 'table1|table2|table3' (default: none)\n\t-n, --no_binary       disable binary download", 
                "name": "migrate"
            }, 
            {
                "content": "## ctindex\n### Usage: ctindex [--mode=MODE] [--domain=DOMAIN] [--port=PORT] [--skip=SKIP]\n\n### Options:\n\t-h, --help            show this help message and exit\n\t-m MODE, --mode=MODE  may be: 'refcount' (default - count up all foreignkey\n\t                      references for sort orders and such); 'index' (assign\n\t                      each record a sequential integer index); 'urlsafekeys'\n\t                      (update all key/keylist properties to use urlsafe keys\n\t                      introduced in ct 0.8); 'cleanup' (delete zero-count\n\t                      reference counters). Note regarding 'index' mode: it\n\t                      _must_ happen remotely; it's generally unnecessary\n\t                      unless you're trying to migrate an unindexed database\n\t                      away from gae and need an index/key per record; it\n\t                      should be invoked from _outside_ -- that's right,\n\t                      outside -- of your project's directory (to avoid\n\t                      loading up a bunch of google network tools that may be\n\t                      crappy or cause issues outside of their normal\n\t                      'dev_appserver' environment)\n\t-d DOMAIN, --domain=DOMAIN\n\t                      ('index' mode only) what's the domain of the target\n\t                      server? (default: localhost)\n\t-p PORT, --port=PORT  ('index' mode only) what's the port of the target\n\t                      server? (default: 8080)\n\t-s SKIP, --skip=SKIP  skip these tables ('index' mode only) - use '|' as\n\t                      separator, such as 'table1|table2|table3' (default:\n\t                      none)\n\nAs you can see, this script's behavior changes according to the backend of the target project.\n\n### dez\nRun this if your CTRefCount records get messed up for\nsome reason. It will go through and recount everything\n(in the default 'refcount' mode -- the other modes,\n'urlsafekeys' and 'cleanup', are for migrating a CT-mediated\ndatabase from an older deployment to CT 0.8 or newer).\n\n### gae\nRun this in 'index' mode on a database with lots of missing index values.", 
                "name": "index"
            }, 
            {
                "content": "## ctdoc\n\n### Usage: ctdoc [-w]\r\n\r\n### Options:\r\n    -h, --help  show this help message and exit\r\n    -w, --web   build web docs\r\n\r\nRun either from cantools root (contains setup.py, cantools/, README.md, etc) or\r\nfrom root of plugin. In cantools, builds docs for all frontend (js) and CLI (py)\r\nfiles. In plugin, docs consist of about file (about.txt), initialization config\r\n(init.py) and default frontend config (js/config.js) (TODO: application mode,\r\nwhich recursively includes any py/js file with a docstring at the top).\r", 
                "name": "doc"
            }
        ], 
        "name": "Back (CLI)"
    }, 
    {
        "children": [
            {
                "content": "## CT.Drop\n### Import line: 'CT.require(\"CT.Drop\");'\nThis class makes a drop-down menu, and can be subclassed\ninto things like the CT.autocomplete classes.", 
                "name": "Drop.js"
            }, 
            {
                "content": "## CT.Pager\n### Import line: 'CT.require(\"CT.Pager\");'\nThis class is used to generate a pager, which is a self-refilling DOM element.\n\n### The constructor takes four positional arguments:\n    - renderCb: function that returns formatted content given an array of data objects\n    - requestCb: function that acquires new raw data\n    - limit (default: 20): number of items to request/display at a time\n    - nodeClass (optional): CSS class of pager DOM node\n    - nodeId (optional): CSS id of pager DOM node", 
                "name": "Pager.js"
            }, 
            {
                "content": "## CT.admin\n### Import line: 'CT.require(\"CT.admin\");'\nThis module includes submodules for interacting with the admin backend:\n\n    - CT.admin.core\n    - CT.admin.db\n    - CT.admin.memcache\n    - CT.admin.pubsub", 
                "name": "admin.js"
            }, 
            {
                "content": "## CT.align\n### Import line: 'CT.require(\"CT.align\");'\nThis module contains functions for determining\ndimensions of and positioning DOM elements.", 
                "name": "align.js"
            }, 
            {
                "content": "## CT.all\n### Import line: 'CT.require(\"CT.all\");'\nThis loader imports almost every CT module.\n\n### This includes:\n    - CT.Drop\n    - CT.Pager\n    - CT.align\n    - CT.autocomplete\n    - CT.canvas\n    - CT.data\n    - CT.db\n    - CT.drag\n    - CT.dom\n    - CT.file\n    - CT.gesture\n    - CT.key\n    - CT.mobile\n    - CT.modal\n    - CT.panel\n    - CT.parse\n    - CT.pubsub\n    - CT.recaptcha\n    - CT.slider\n    - CT.storage\n    - CT.trans\n    - CT.upload\n    - CT.video\n\n### This excludes:\n    - CT.map, CT.pay, and CT.rte, which require large script imports\n    - CT.admin, which is not for typical use.", 
                "name": "all.js"
            }, 
            {
                "content": "## CT.autocomplete\n### Import line: 'CT.require(\"CT.autocomplete\");'\nThe purpose of this module is to simplify the creation of DOM\ntext fields that autocomplete user input based on some data set.\n\nThis module contains two classes, Guesser and DBGuesser.\n\n### CT.autocomplete.Guesser\n\nGuesser is a subclass of CT.Drop.\n\n#### The constructor takes an options object with any or all of the following properties:\n    - enterCb (default: doNothing): trigger when user hits enter\n    - keyUpCb (default: doNothing): trigger on key up\n    - expandCB (default: doNothing): trigger when autocomplete node expands\n    - tapCb (default: set input to data.label): trigger on option tap\n    - guessCb (default: this.guesser): trigger when it's time to guess\n    - input (required): the input node to which to attach the autocomplete guesser\n    - data (default: []): array of label-containing objects used by default guesser\n\nTo specify custom guessing behavior, either pass in a 'guessCb' function to the\nconstructor or subclass Guesser, adding this function to the class (as 'guesser').\n\n### CT.autocomplete.DBGuesser\nDBGuesser subclasses Guesser, and defines a 'guesser'\nfunction, which uses the CT.db module to acquire data.\n\n#### DBGuesser's constructor supports a few more properties:\n    - modelName: the name of the backend database model to query from\n    - property: the property (on specified model) to compare to text input\n    - filters (default: {}): filters to apply to database query", 
                "name": "autocomplete.js"
            }, 
            {
                "content": "## CT.canvas\n### Import line: 'CT.require(\"CT.canvas\");'\nThis module contains classes that simplify use of the HTML5 canvas element:\n\n    - CT.canvas.Canvas\n    - CT.canvas.Controller\n    - CT.canvas.Node\n    - CT.canvas.Text", 
                "name": "canvas.js"
            }, 
            {
                "content": "## CT.ct\n### Import line: '&lt;script src=\"/js/CT/ct.js\"&gt;&lt;/script&gt;'\nThis is the cantools bootstrapper. This means that it must be included in\na regular script tag in the head of your html file. It contains the core\nfunctionality of the framework, as follows.\n\n### CT.net\n#### This is where the network stuff lives. Highlights:\n\t- CT.net.post(path, params, errMsg, cb, eb, headers, cbarg, ebarg)\n\t  - issues a POST request via asynchronous XHR\n\t- CT.net.get(path, qsp, isjson, ctjson)\n\t  - issues a GET request via synchronous XHR\n\t  - optionally parses query string object and unpacks response as JSON\n\t- CT.net.put(path, params, cb, headers)\n\t  - issues a PUT request via asynchronous XHR\n\t- CT.net.delete(path, params, cb, headers)\n\t  - issues a DELETE request via asynchronous XHR\n\n#### Also includes:\n\t- CT.net.setMode(string) (default: 'ct')\n\t  - also supports:\n\t    - 'basic', which skips request prepping and response code processing\n\t    - 'passthrough', which does nothing (doesn't even JSON stringify)\n\t- CT.net.setSpinner(bool) (default: false)\n\t  - enables/disables spinner (indicating outstanding request)\n\t- CT.net.setCache(bool) (default: false)\n\t  - enables/disables client-side request caching\n\t- CT.net.setSilentFail(bool) (default: true)\n\t  - enables/disables alert-level error reporting (if otherwise undefined)\n\t- CT.net.setEncoder(func)\n\t  - sets encoder (upstream data processing function)\n\t  - must be used in conjunction with cantools.web.setenc()\n\t- CT.net.setDecoder(func)\n\t  - sets decoder (downstream data processing function)\n\t  - must be used in conjunction with cantools.web.setdec()\n\t- CT.net.xhr(path, method, params, async, cb, headers)\n\t  - thin wrapper around browser-level XHR abstraction\n\n### CT.require(modname, lazy)\nThis is the basis of the cantools module system. Any time your code requires\na module (CT or otherwise), simply call CT.require('MyProject.submodule.whatever')\nto dynamically pull in the necessary code. When your project is compiled in\nproduction mode, these imports are baked into the host HTML file, _except_\nthose flagged 'lazy' (second argument is 'true').\n\n### CT.scriptImport(modpath, cb, delay)\nThis function supports the importation of libraries that only work if they\nknow their path (which they ascertain by checking their own script tag).\nThis includes many popular libraries, such as TinyMCE and Google Maps.\n\n### CT.onload(cb)\nRegisters a callback to be fired when the window loads.\n\n### CT.merge()\nMerges arbitrary number of objects into new object and returns result.\n\n### CT.Class(obj, parent)\nThis function creates a cantools class. The first argument is a class\ndefinition, an object containing all the functions and properties\nbelonging to the class. The second (optional) argument is the base\nclass from which to inherit.\n\nIf the class definition includes a 'CLASSNAME' property, this is used\nfor logging (each class instance has its own 'log' function). Otherwise,\na warning is generated.\n\nIf the class definition includes an 'init' function, this function\nbecomes the class constructor, which is called when an instance is\ncreated (var instance_of_ClassA = new ClassA([args])).\n\nAll class functions are bound to the instance, including those\nembedded in data structures.\n\n### CT.log\nThis module contains functions for logging, acquiring specific loggers,\nand filtering log output, as well as timing functions for profiling code.\n\n### shims\nIn addition to the above functions and modules, the cantools bootstrapper provides a\nnumber of shims - fallback implementations of key functionality - for old browsers.\nThese are required lazily, meaning that they are _not_ included in production-compiled\ncode, and they're only imported as needed (when missing from browser).\n\n#### These include:\n\t- JSON\n\t- sessionStorage\n\t- classList\n\t- requestAnimationFrame\n\t- Object.values\n\t- addEventListener", 
                "name": "ct.js"
            }, 
            {
                "content": "## CT.data\n### Import line: 'CT.require(\"CT.data\");'\nThis module contains functions for:\n\n    - structure comparison\n    - array manipulation\n    - object caching\n    - data acquisition", 
                "name": "data.js"
            }, 
            {
                "content": "## CT.db\n### Import line: 'CT.require(\"CT.db\");'\nThis module provides direct integration with the cantools.db backend\nvia the _db.py request handler. Some key functions are defined below.\n\n### CT.db.getSchema(modelName)\nReturn the schema for the named model.\n\n### CT.db.setSchema(schema)\nSets CT.db._schema, which includes every model in the database. This is\ncalled automatically by CT.db.init(), which acquires it from the backend.\n\n### CT.db.get(modelName, cb, limit (default: 20), offset (default: 0), order, filters)\nAcquire the data set defined by the given query parameters, add\nit to CT.data's map, and pass it back via callback function (cb).\n\n### CT.db.multi(keys, cb)\nAcquire data objects corresponding to members of 'keys' array, add\nthem to CT.data's map, and pass them back via callback function (cb).\n\n### CT.db.one(key, cb)\nAcquire data object corresponding to 'key' string, add it to\nCT.data's map, and pass it back via callback function (cb).\n\n### CT.db.init(opts)\nAcquire and set the database schema. Establish CT.db._opts object used by\nUI elements for querying database and adding/editing records. These include:\n\n    - builder (required):\n      - this generator function, given a modelName, returns a render callback\n        for internal use with CT.panel.pager().\n    - panel_key (default: 'db'):\n      - this optional string argument may be used to indicate the desired parent\n        node of a pager element (generated by CT.db.pager()).\n    - post_pager (optional):\n      - this function is called whenever a pager is generated via CT.db.pager().\n\n### CT.db.query(opts, transition)\nThis function generates a modal (CT.modal.Modal) containing a query node\n(CT.db.Query) constructed with opts. The modal appears onscreen with the\nindicated transition (defaults to 'none').\n\n### CT.db.pager(modelName, order, filters, k, cnode)\nThis function creates a pager node (CT.Pager [via CT.panel.pager()] refilled\nvia CT.db.get() used in conjunction with modelName, order, filters). It then\nadds this node to a parent indicated by cnode or (if undefined) determined by\nk (which falls back to modelName) and panel_key (set by CT.db.init(), defaults\nto 'db'). Finally, if a 'post_pager' callback has already been defined by\nCT.db.init(), this callback is invoked, passing in key and modelName.\n\n### CT.db.edit (submodule)\nThis submodule contains functions for building interface elements that\nenable direct creation and modification of database records. This includes\nthe CT.db.edit.EntityRow class, of which such interfaces primarily consist.\n\n### CT.db.Query (class)\nThis class (often used in conjunction with CT.modal.Modal) builds a DOM node\ncontaining the interface elements necessary to define a query against the specified\ntable. The constructor takes an options object ('opts') with three possible entries:\n\n    - showHelp: indicates whether or not to show help strings in the query node\n      - default: false\n    - pagerPanelId: specifies parent node for pager generated by default submit\n      - default: 'dbqueries'\n    - submit: the function to call when the 'submit' button is clicked\n      - default: pager node is created and added to parent indicated by pagerPanelId", 
                "name": "db.js"
            }, 
            {
                "content": "## CT.dom\n### Import line: 'CT.require(\"CT.dom\");'\nThis module contains functions for interacting with the DOM. This includes:\n\n### simple and compound node creation\n#### CT.dom.node(content, type, classname, id, attrs, style)\n\t- content - what goes in the resulting DOM node. may be:\n\t  - a node\n\t  - a function\n\t  - an object\n\t  - a string or number\n\t  - an array containing any of the above\n\t- type - tag name of resulting DOM node\n\t- classname - class of resulting DOM node\n\t- id - id of resulting DOM node\n\t- attrs - object defining miscellaneous properties of resulting DOM node\n\t- style - object mapping CSS properties to values\n\nAll other node generators use CT.dom.node() under the hood. There are many. See code.\n\n### selectors\n#### CT.dom.id(id, all)\n\t- 'all' is a bool indicating whether to also search free-floating nodes.\n#### CT.dom.className(cname, n)\n\t- 'n' is the node to search. defaults to document.\n#### CT.dom.tag(tag, n)\n\t- 'n' is the node to search. defaults to document.\n#### CT.dom.Q(q, n)\n\t- executes querySelectorAll(q) on n (defaults to document)\n\n### style modding\n#### CT.dom.mod(opts)\n\t- 'opts' object must include:\n\t  - property: CSS property to modify\n\t  - value: new value\n\t- 'opts' object must include one of:\n\t  - target (node)\n\t  - targets (node array)\n\t  - className (string)\n\t  - id (string)\n#### CT.dom.addStyle(text, href, obj)\n\t- use EITHER text, href, or obj\n\t  - text: raw CSS text\n\t  - href: url of stylesheet\n\t  - obj: object mapping selector strings to style definitions (specified\n\t\t\t via embedded objects mapping CSS properties to values)", 
                "name": "dom.js"
            }, 
            {
                "content": "## CT.drag\n### Import line: 'CT.require(\"CT.drag\");'\nThis module enables cross-platform, sometimes-native dragging, mostly via\nCT.gesture module. The principle function is makeDraggable(), used as follows:\n\n### CT.drag.makeDraggable(node, opts)\nThis function makes the 'node' node draggable. The 'opts' object may contain\nany or all of the following options:\n\n    - constraint ('horizontal' or 'vertical'): prevents drags in indicated direction.\n    - interval (number): 'chunks' total drag area into sections, causing drags to\n                         always settle on areas corresponding to multiples of 'interval',\n                         and swipes to slide between such areas. if value is 'auto',\n                         we use width / number_of_child_nodes.\n    - force (bool, default false): forces non-native scrolling.\n    - up, down, drag, scroll, swipe (functions): optional gesture callbacks.", 
                "name": "drag.js"
            }, 
            {
                "content": "## CT.file\n### Import line: 'CT.require(\"CT.file\");'\nThis module provides functions and a class (CT.file.File) for\nmessing with (accessing, uploading, downloading) file objects.", 
                "name": "file.js"
            }, 
            {
                "content": "## CT.gesture\n### Import line: 'CT.require(\"CT.gesture\");'\nThis module contains functions for registering cross-platform gesture callbacks.\nThe main one to look out for is listen, defined below.\n\n### CT.gesture.listen(eventName, node, cb, stopPropagation, preventDefault)\n    - eventName - one of: drag, swipe, tap, up, down, hold, pinch, hover, wheel\n    - node - the node to listen to\n    - cb - the function to call when something happens\n    - stopPropagation - whether to propagate this event beyond node\n    - preventDefault - whether to prevent default behavior", 
                "name": "gesture.js"
            }, 
            {
                "content": "## CT.key\n### Import line: 'CT.require(\"CT.key\");'\nThis module supports global key bindings.", 
                "name": "key.js"
            }, 
            {
                "content": "## CT.layout\n### Import line: 'CT.require(\"CT.layout\");'\nThis module provides functions that generate common UI elements. These include:\n\n### header(opts) - defaults:\n\tlogo: \"Placeholder Logo\"\n\tright: []\n\tcenterLogo: true\n\n### footer(opts) - defaults:\n\tlogo: \"Placeholder Logo\"\n\tlinks: []\n\tcontact: {}\n\n### grid(data, columns, rows, hardheight) - defaults:\n\tcolumns: 3\n\trows: 4", 
                "name": "layout.js"
            }, 
            {
                "content": "## CT.map\n### Import line: 'CT.require(\"CT.map\");'\nThis module loads the Google Maps API via CT.scriptImport(),\nas well as a utility submodule (CT.map.util) and four classes:\n\n    - CT.map.Map\n    - CT.map.Node\n    - CT.map.Marker\n    - CT.map.Shape", 
                "name": "map.js"
            }, 
            {
                "content": "## CT.mobile\n### Import line: 'CT.require(\"CT.mobile\");'\nThis module takes a website formatted for a regular computer screen\nand, via configuration, mobilizes it by zooming in on specific sections\nof the page and providing user interface elements for scaling/translating\nbetween components.", 
                "name": "mobile.js"
            }, 
            {
                "content": "## CT.modal\n### Import line: 'CT.require(\"CT.modal\");'\nThis module contains three classes, Modal, LightBox, and Prompt.\n\n### CT.modal.Modal\nCreates a DOM node that can be transitioned\non- and off- screen to/from a configurable position.\n\ndefaults:\n\t{\n\t\tclassName: \"basicpopup\",\n\t\ttransition: \"none\", // none|fade|slide\n\t\tcenter: true,\n\t\tnoClose: false, // turns off 'x' in corner\n\t\tslide: { // only applies if transition is 'slide'\n\t\t\torigin: \"top\"\n\t\t}\n\t}\n\nNote that the optional 'slide' object -- which only applies when\ntransition is 'slide' -- may include 'top', 'left', 'bottom', and 'right'\nproperties. For any other transition (when center is false), please\nposition your node via css class (specified via 'className' property).\n\n### CT.modal.LightBox (Modal subclass)\nCentered, almost-fullscreen, fade-in, image-backed modal with translucent backdrop.\n\ndefaults:\n\t{\n\t\tclassName: \"backdrop\",\n\t\ttransition: \"fade\",\n\t\tcaption: \"\",\n\t\tnoClose: true\n\t}\n\n\n### CT.modal.Prompt (Modal subclass)\nIncludes interface elements for obtaining user input, such as\na string, a password, or one or more selections from a list.\n\ndefaults:\n\t{\n\t\tstyle: \"string\", // string|password|single-choice|multiple-choice|file\n\t\tprompt: \"\",\n\t\tdata: [] // only applies to choice styles\n\t}", 
                "name": "modal.js"
            }, 
            {
                "content": "## CT.panel\n### Import line: 'CT.require(\"CT.panel\");'\nThis module contains functions for generating lists of items that,\nwhen clicked, show corresponding content or trigger corresponding\nlogic. Here are three examples.\n\n### CT.panel.simple(pnames, keystring, itemnode, panelnode, cbs)\nThis function wraps CT.panel.load(), supporting a subset of load()'s\noptions (the simple ones). It supports the following args, of which\nonly the first is required:\n\n    - pnames (string array): short for 'panel names'\n    - keystring (string, default: 'sb'): identifier for collections of content/lister nodes\n    - itemnode (node, default: CT.dom.id(keystring + \"items\")): parent node for lister items\n    - panelnode (node, default: CT.dom.id(keystring + \"panels\")): parent node for content panels\n    - cbs (function array, optional): callbacks to invoke on lister item click post- panel swap\n\n### CT.panel.pager(getContent, request, limit, colClass, dataClass, ks)\nThis function generates and returns a node containing a\n(CT.Pager-backed) paging lister node and a corresponding content panel.\n\n    - getContent (function): combined with CT.panel.simple() in pager's renderCb\n    - request (function): pager's requestCb\n    - limit (number, default: 20): pager's limit (chunk size)\n    - colClass (string, optional): class of generated pager (list selector) node\n    - dataClass (string, optional): class of generated data (content panel) node\n    - ks (string, default: \"p\" + CT.Pager._id): keystring of data and list nodes\n\n### CT.panel.triggerList(data, cb, node)\nThis function fills the 'node' node with a list of clickable items, each of\nwhich triggers cb(d), where d is the corresponding object in the 'data' array.\n\n    - data (object array): data set used to generate list\n      - for d in data: link content equals d.label || d.title\n    - cb (function): the callback to invoke when an item is clicked\n    - node (node): the list parent node", 
                "name": "panel.js"
            }, 
            {
                "content": "## CT.parse\n### Import line: 'CT.require(\"CT.parse\");'\nThis module contains functions for manipulating and processing text. This includes:\n\n### parsing\nMainly, you'll just want to call CT.parse.process(c, simple, customArg).\n\n#### It returns the processed string and supports 3 positional arguments:\n    - c (string)\n      - the text to process\n    - simple (bool)\n      - if true, uses simple link wrapping\n      - else (default), embeds images and invokes custom processor (if any)\n    - customArg (anything)\n      - passed to custom link processor, if any (for indicating some mode, for instance)\n\n#### Furthermore:\n    - normalizes whitespace\n    - formats and embeds links for phone numbers\n    - generates mailto links as necessary\n    - processes remaining links via url2link() or processLink() (switching on simple)\n\n### link processing\nThis is done through CT.parse.processLink(url, customArg).\n\n#### It supports two arguments:\n    - url: url to parse\n    - customArg: passed to custom processor, for instance, for disabling embedded video\n\n#### Furthermore:\n    - embeds images\n    - linkifies other links\n    - adds 0-width whitespace characters to line-break url strings as necessary\n      - via CT.parse.breakurl(url)\n    - supports custom link processing callbacks\n      - via CT.parse.setLinkProcessor(cb)\n\n### input constraints/validation\n\tCT.parse.validEmail(s): returns bool\n\tCT.parse.validPassword(s): returns bool\n\tCT.parse.numOnly(n, allowDot, noNeg): returns n\n\t - turn 'n' input into a field that only allows numbers\n\t - allowDot and noNeg toggle decimals and negative #s\n\n### strippers, formatters, converters, sanitization\nVarious functions for deriving different types of information, such as\nphone numbers and zip codes, from text; reformatting recognizable strings\nand generating links (as in the case of phone numbers); case-modding,\nsoft-truncating, and removing script blocks from text; and otherwise messing\nwith strings. Also, CT.parse.timeStamp(datetime) goes a long way toward\nmaking timestamps meaningful to humans.", 
                "name": "parse.js"
            }, 
            {
                "content": "## CT.pay\n### Import line: 'CT.require(\"CT.pay\");'\nThis module contains a class, CT.pay.Form, that, in conjunction\nwith a tightly-coupled backend component (_pay.py), provide\nintegration with the Braintree payment platform, which supports:\n\n\t- PayPal\n\t- Credit Cards\n\t- Venmo\n\t- Apple Pay\n\t- Android Pay\n\t- Bitcoin?", 
                "name": "pay.js"
            }, 
            {
                "content": "## CT.pubsub\n### Import line: 'CT.require(\"CT.pubsub\");'\nThis module provides a direct interface with the ctpubsub backend. Here's how to use it.\n\n\tCT.pubsub.connect(host, port, uname)\n\tCT.pubsub.publish(channel, message)\n\tCT.pubsub.subscribe(channel)\n\tCT.pubsub.unsubscribe(channel)\n\tCT.pubsub.pm(user, message)\n\tCT.pubsub.set_cb(action, cb)\n\tCT.pubsub.set_reconnect(bool)\n\tCT.pubsub.isInitialized() (returns bool)", 
                "name": "pubsub.js"
            }, 
            {
                "content": "## CT.recaptcha\n### Import line: 'CT.require(\"CT.recaptcha\");'\nThis module provides functions, build() and submit(),\nfor messing around with recaptcha botwalls.\n\nTODO: this functionality requires backend\nintegration - include complementary python module!", 
                "name": "recaptcha.js"
            }, 
            {
                "content": "## CT.rte\n### Import line: 'CT.require(\"CT.rte\");'\nThis module provides two functions, wysiwygize() and qwiz(), which\nboth convert textareas (identified by id) into rich text editors.\n\n### CT.rte.wysiwygize(nodeid, isrestricted, val, cb, mismatchcb)\n\t- nodeid: id of target textarea (must exist in DOM)\n\t- isrestricted: if true, disables tables and images\n\t- val: string value with which to initialize target text area\n\t- cb: callback to invoke once textarea is initialized\n\t- mismatchcb: callback to invoke if the reformatted text doesn't match val\n### CT.rte.qwiz(nodeid, val)\n\t- nodeid: id of target textarea (must exist in DOM)\n\t- val: string value with which to initialize target text area\n\nCT.rte.qwiz() just builds a simplified (isrestricted=true) rich text area\nafter first waiting for the nodeid-indicated node to appear in the DOM.\n\nCT.rte requires the open-source TinyMCE library, pulled in via CT.scriptImport().", 
                "name": "rte.js"
            }, 
            {
                "content": "## CT.slider\n### Import line: 'CT.require(\"CT.slider\");'\nThis class is used to generate a slider, which is a segmented,\ndirectionally-constrained draggable DOM element.\n\nThe CT.slider.Slider constructor takes an options object, 'opts', which may\ndefine any of several properties. These individual properties, as well as\nthe 'opts' object itself, are all optional.\n\n### Definable properties are as follows:\n    - parent (default: document.body): DOM element in which to build the slider\n    - mode (default: 'peekaboo'): how to display each frame - 'peekaboo', 'chunk', 'menu', 'profile', or 'track'\n    - subMode (default: 'peekaboo'): which mode to use for chunk-mode frames ('peekaboo', 'menu', 'profile', 'track')\n    - defaultImg (default: undefined): fallback img for any frame mode\n    - img (default: undefined): panning background image for whole slider. also works per-chunk.\n    - autoSlideInterval (default: 5000): how many milliseconds to wait before auto-sliding frames\n    - panDuration (default: autoSlideInterval): pan duration for background images\n    - autoSlide (default: true): automatically proceed through frames (else, trigger later with .resume())\n    - visible (default: true): maps to visibility css property\n    - navButtons (default: true): include nav bubbles and arrows\n    - circular (default: false): allow shifting between 1st and last frames w/ nav buttons (arrows)\n    - pan (default: true): slow-pan frame background images\n    - translucentTeaser (default: true): translucent box around teaser text (otherwise opaque)\n    - startFrame (default: null): label (or index if frames are unlabeled) of frame to slide to initially (disables autoSlide)\n    - bubblePosition (default: 'bottom'): where to position frame indicator bubbles ('top' or 'bottom')\n    - arrowPosition (default: 'middle'): where to position navigator arrows\n    - orientation (default: 'horizontal'): orientation for slider frames to arrange themselves\n    - keys (default: true): use arrow keys to navigate slider, as well as enter key for peekaboo transitions\n    - frames (default: []): an array of items corresponding to the frames in the slider\n\nThe last one, 'frames', must be an array either of strings (interpreted\nas image urls) or of data objects (processed in the addFrame function).", 
                "name": "slider.js"
            }, 
            {
                "content": "## CT.storage\n### Import line: 'CT.require(\"CT.storage\");'\nThis module provides an abstraction layer over a storage backend.\n\n### Here are the obvious functions:\n    - CT.storage.get(key)\n    - CT.storage.set(key, val)\n    - CT.storage.clear()\n\n### You also have to call CT.storage.init(opts). The 'opts' object may contain:\n    - backend (one of: localStorage, sessionStorage) - default: localStorage\n    - json (bool) - default: true\n    - compress (bool) - default: true\n\nWhy call init(), you ask? Well, if 'compress' is true, the storage module\nneeds to lazily import CT.lib.lz-string. Could be different, but there it is.", 
                "name": "storage.js"
            }, 
            {
                "content": "## CT.trans\n### Import line: 'CT.require(\"CT.trans\");'\nThis module provides convenience functions for messing\naround with DOM elements via CSS transitions. Have at it.\n\n### Try out these functions:\n\tCT.trans.rotate(node, opts)\n\tCT.trans.translate(node, opts)\n\tCT.trans.wobble(node, opts)\n\tCT.trans.pan(node, opts, wait)\n\tCT.trans.resize(node, opts)\n\tCT.trans.fadeIn(node, opts)\n\tCT.trans.fadeOut(node, opts)\n\tCT.trans.pulse(node, opts)\n\tCT.trans.trans(opts)\n\tCT.trans.setVendorPrefixed(node, property, value)\n\t - sets CSS properties for all vendor prefixes\n\t   - [ \"-webkit-\", \"-moz-\", \"-ms-\", \"-o-\", \"\" ]\n\n### And here are the default options:\n\ttrans: {\n\t\tduration: 500,\n\t\tproperty: \"*\",\n\t\tease: \"ease-in-out\"\n\t},\n\trotate: {\n\t\tdegrees: 180,\n\t\tduration: 1000,\n\t\tproperty: \"transform\",\n\t\tease: \"linear\",\n\t\tprefix: true\n\t},\n\ttranslate: {\n\t\tduration: 300,\n\t\tproperty: \"transform\",\n\t\tease: \"linear\",\n\t\tprefix: true,\n\t\tx: 0,\n\t\ty: 0,\n\t\tz: 0\n\t},\n\twobble: {\n\t\taxis: \"x\",\n\t\tradius: 50,\n\t\tduration: 100\n\t},\n\tpan: {\n\t\tduration: 5000,\n\t\tease: \"linear\",\n\t\tx: 0,\n\t\ty: 0\n\t},\n\tresize: {\n\t\tduration: 300,\n\t\tease: \"linear\"\n\t},\n\tfadeIn: {\n\t\tduration: 1600,\n\t\tproperty: \"opacity\",\n\t\tvalue: 1\n\t},\n\tfadeOut: {\n\t\tduration: 1600,\n\t\tproperty: \"opacity\",\n\t\tvalue: 0\n\t},\n\tpulse: {\n\t\twait: 1000\n\t}\n\nTODO: let's add some more, like scale.\n\nCertain functions (pan() and pulse()) return a CT.trans.Controller instance.\n\n### CT.trans.Controller\n\tpause()  - stop the transition (for now)\n\tresume() - resume the transition\n\tactive() - returns status of transition (bool)\n\ttick()   - calls cb() if active()\n\tinit(cb) - cb() is called by tick() if active()", 
                "name": "trans.js"
            }, 
            {
                "content": "## CT.upload\n### Import line: 'CT.require(\"CT.upload\");'\nThis module supports file uploads.\n\n### CT.upload.form(uid, kval, sbutton, isize)\n\t- uid: user id (if any)\n\t- kval: upload key (if any)\n\t- sbutton: submit button (if any)\n\t- isize: input size (in characters)\n\n### CT.upload.submit(f, success, failure, iskey)\n\t- f: input field\n\t- success: upload success callback\n\t- failure: upload failure callback\n\t- iskey: whether a key is expected as the return value\n\nThis module lazily imports CT.lib.aim (in submit()).\n\nTODO: remove/replace uid/kval/iskey -- too application-specific", 
                "name": "upload.js"
            }, 
            {
                "content": "## CT.video\n### Import line: 'CT.require(\"CT.video\");'\nThis module supports video playback.\n\n### video players\nWe support Google Video, YouTube, Vimeo, and uStream.\n\n### raw formats\nWe support mp4, ogg, and webm.\n\nTypically, you'll want to use the fit() function.\n\n### CT.video.fit(video)\n\t- returns stringified html for a video node fitting snugly inside its parent", 
                "name": "video.js"
            }
        ], 
        "name": "Front (JS Library)"
    }
];